

对于GPU来说，屏幕渲染分为两种：On-Screen Rendering 和 Off-Screen Rendering
区分在于Off-Screen Rendering不在GPU的当前屏幕缓冲区中进行的渲染
因此，针对一点，就还有一种特殊的“离屏渲染”方式：CPU渲染
{
    如果我们重写了drawRect方法，并且使用任何Core Graphics的技术进行了绘制操作，就涉及到了CPU渲染。整个渲染过程由 CPU 在 APP 内同步地完成，渲染得到的 bitmap 最后再提交由 GPU 用于显示（用CPU渲染，会有很大的内存消耗，这一点需要尤为注意---目前我理解为：通过CPU消耗内存，来节省GPU渲染时间，已达到屏幕流畅的目的）
}


如何抉择：
      现在摆在我们面前得有三个选择：当前屏幕渲染、离屏渲染、CPU渲染，该用哪个呢？这需要根据具体的使用场景来决定。

      1.  尽量使用当前屏幕渲染
      鉴于离屏渲染、CPU渲染可能带来的性能问题，一般情况下，我们要尽量使用当前屏幕渲染。

      2.  离屏渲染 VS CPU渲染
      由于GPU的浮点运算能力比CPU强，CPU渲染的效率可能不如离屏渲染；但如果仅仅是实现一个简单的效果，直接使用CPU渲染的效率又可能比离屏渲染好，毕竟离屏渲染要涉及到缓冲区创建和上下文切换等耗时操作。


Quartz是建立在CPU基础之上的绘图引擎（Core Graphics）
在iOS中，offscreen drawing发生在一下情况：
   CPU
      1.  Core Graphics (任何带有CG前缀的类)
      2.  drawRect() 方法（即使只是一个空的implementation）
   GPU 
      3.  CALayers 的shouldRasterize被设置为YES
      4.  CALayers 设置 setMasksToBounds 和 setShadow
      5.  UIViewGroupOpacity
   待定
      6.  任何 text 文本在屏幕上显示，包括 Core Text
      
在动画被调用的时候，offscreen drawing 会造成性能影响
offscreen rendering should be avoided during visualization in scrollview etc

离屏渲染和在屏渲染。两者速度是一样的，主要区别是在屏渲染是在hardware上，而离屏渲染是在software

or good performance, the trick is to avoid using software drawing for views that change every frame. For example, if you need an animated vector shape you'll get better performance using CAShapeLayer or OpenGL than drawRect and Core Graphics. But if you draw a shape once and then don't need to change it, it won't make much difference.

预先渲染资源（pre-rendered assets）仍然是比任何解决性能方法中最好的（这种一般是通过GPU去渲染图片资源然后存储在磁盘中）

一个混合CPU与GPU渲染的方式：
   生成一个bitmap image,然后在所以实例对象中去重复使用它

