
表单提交 post和get的区别？
1、get方式提交会把参数显示在地址
post方式提交不会把参数显示在地址栏上。（请求体）				
2、get方式敏感信息不安全
   post方式敏感信息相对安全
3、get方式提交，官方限制提交大小仅1KB（但多数浏览器可以提交2KB）
   post方式提交，提交大数据。一般用于附件上传

#import <objc/runtime.h>
runtime——给OC类别，扩展属性
         (关联对象与被关联对象本身的存储并没有直接的关系，它是存储在单独的哈希表中的)
       > 对象地址与AssociationsHashMap哈希表是一一对应的（因此，我们也可以给类对象添加关联对象）
       > 流程： self ---> ObjectAssociationMap对象 ----> ObjectAssociationHashMap

copy、strong、assign存储策略


搜索实现关键字联想（接口端请求获取）
cell根据图片高度来自适应高度，需要服务器端先告诉图片的尺寸，否则无法实现，因为即时刷新效率很低，
swift1.0~2.0区别——字符串获取长度有变：先获取到C的字符串，在获取C字符串的长度
WatchKit使用
视频APP用到的框架以及第三方库
获取iOS设备的内存状况
UIImagePickerController自定义导航栏—因为他也是一个导航控制器，可以修改，其navigationBar
图片渐进加载——大图片会影响性能！

喜欢自定义func myLayoutSubviews()这样是因为系统的LayoutSubviews()不容易控制，在很多情况下会调用，这导致一个可变的frame，出现了可控制性


造成循环引用的三种场景：
原因：可以简单地理解为A引用了B，而B又引用了A，双方都同时保持对对方的一个引用，导致任何时候引用计数都不为0，始终无法释放。
第一种：
第二种：block函数
第三张：委托delegate——平时注意申明代理属性的时候，用assign(MRC)或者weak(ARC)，不能使用retain或者strong


runtime实现机制
runtime是一套比较底层的纯C语言API，属于1个C语言库，包含了很多底层的C语言API。
在我们平时编写的OC代码中，程序运行过程中，其实最终都是转成runtime的C语言代码，runtime算是OC的幕后工作者。
例如：
OC：[[MJPerson alloc]init]=====>
runtime：objc_msgSend(objc_msgSend(“MJPerson”,”allow”),”init”)

runtime用途：
1.在程序运行过程中，动态创建一个类（比如KVO的底层实现—————MJExtension处理数据模型）
2.在程序运行过程中，动态地为某个类添加属性\方法，修改属性值\方法（比如：对类别进行属性扩展，通过改变方法名指针指向来交换方法的实现）
例如：交换方法实现
Method ori_Method = class_getInstanceMethod([NSArray class], @selector(lastObject));
Method my_Method = class_getInstanceMethod([NSArray class], @selector(myLastObject));
method_exchangeImplementations(ori_Method, my_Method);
3.遍历一个类的所有成员变量（属性）\所有方法（因为NSObject在runtime里就是一个结构体）

设计模式：
单例、代理、通知


##已知的编程思想：《参考代码———ReactiveCocoa文件夹》
1>面向过程：处理事情以过程为核心，一步一步的实现。
2>面向对象：万物皆对象
3>链式编程思想：是将多个操作（多行代码）通过点号(.)链接在一起成为一句代码，使代码可读性好。a(1).b(2).c(3),这个点号式，本质（原理）运用到的是OC的setter.getter方法
         链式变成特点：方法的返回值是block,block必须有返回值（本身对象），block参数（需要操作的值）
         代表：masonry框架
4>响应式编程思想：不需要考虑调用顺序，只需要知道考虑结果，类似于蝴蝶效应，产生一个事件，会影响很多东西，这些事件像流一样的传播出去，然后影响结果，借用面向对象的一句话，万物皆是流。
         代表：KVO运用、通知中心。
5>函数式编程思想：是把操作尽量写成一系列嵌套的函数或者方法调用。
         函数式编程特点：每个方法必须有返回值（本身对象），把函数或者Block当做参数，block参数（需要操作的值）block返回值（操作结果）
         代表：ReactiveCocoa
       

StoryBoard——右击打开source code——>会看见，系统把storyboard转成xml,然后再解析xml,生成相应的代码

——————————————————————数据结构————————————————————
常用结构：
数组、
栈、
队列、
链表、
树、
图、
堆、
散列表
—————————————————————————————————————————————————————————
平时遇到的难点：
1.多参数的OC函数-	(void)test: (int)x number: (int)y;（带标签的）-	(void)test: (int)y : (int)y;不带标签的（不建议）-	(void)test: (NSDictionary *)data,…;swift多参数函数带标签 func test(name:String, age:Int)不带标签func test(name:String,_ age:Int)对于需要参数名的函数，可以在参数名前面加_来强制取消参数名多参数，带标签与不带标签，这一点在JS与OC交互时，尤为重要！因为JS里面的方法名需要与OC方法名一直！2.UITabbarController里面添加tableView的时候，tableView会往下偏移20个像素。解决办法：- (void)viewDidAppear:(BOOL)animated{    [super viewDidAppear:animated];    self.page.tableView.contentInset = UIEdgeInsetsZero;}另外需要注意的是：首次加载的时候，第一个子视图控制器里面的tableView不会加载viewDidAppear方法，因此，此时需要在tabbarViewController里面去手动调用viewDidAppear方法3.JS与OC交互的时候，如果同样的方法名，但是传的参数类型不一致，则仍然会导致OC方法，无法被调用。

4.
imageV.setImageWithURL(NSURL(string:imageUrl as String),placeholderImage: nil ,completed: { (image, error, imageCachetype) -> Void in })SDWebImage在加载图片的时候，会判断该链接是否为有效链接，如果无效，第二次则不会再去加载请求，也就是说，也不会再调用完成的block代码块，这一点需要注意此外，定位功能也有类似的效果
就是当系统在隐私里把所有的定位权限关闭后，定位成功或者失败的代理方法，是不会走的，但是当单独只设置单个app的定位权限关闭后，定位失败的代理方法是走的———————————————————————————————nonatomic和atomic之间的区别————————————
1.处理器自动保证基本内存操作的原子性
首先处理器会自动保证基本的内存操作的原子性。处理器保证从系统内存当中读取或者写入一个字节是原子的，意思是当一个处理器读取一个字节时，其他处理器不能访问这个字节的内存地址。奔腾6和最新的处理器能自动保证单处理器对同一个缓存行里进行16/32/64位的操作是原子的，但是复杂的内存操作处理器不能自动保证其原子性，比如跨总线宽度，跨多个缓存行，跨页表的访问。但是处理器提供总线锁定和缓存锁定两个机制来保证复杂内存操作的原子性。
因此，会出现以下一种情况：
nonatomic不保证setter/getter的原语行，所以你可能会取不到完整的东西。比如setter函数里面该表两个成员变量，如果你nonatomic的话，getter可能会取到只更改了其中一个变量时候的状态。

2.使用锁机制实现原子操作
锁机制保证了只有获得锁的线程能够操作锁定的内存区域。JVM内部实现了很多种锁机制，有偏向锁，轻量级锁和互斥锁，有意思的是除了偏向锁，JVM实现锁的方式都用到的循环CAS，当一个线程想进入同步块的时候使用循环CAS的方式来获取锁，当它退出同步块的时候使用循环CAS释放锁。详细说明可以参见文章Java SE1.6中的Synchronized。
这个实现的原理是：setter与getter方法访问同一个属性内存，而该内存被锁起来了，因此，可以达到目的。

3.atomic的意思就是setter/getter这个函数是一个原子操作（原子操作（atomic operation）意为"不可被中断的一个或一系列操作" 。在多处理器上实现原子操作就变得有点复杂）（所谓原子操作，就是该操作绝不会在执行完毕前被任何其他任务或事件打断，也就说，它的最小的执行单位，不可能有比它更小的执行单位，因此这里的原子实际是使用了物理学里的物质微粒的概览）。如果有多个线程同时调用setter的话，不会出现某一个线程执行setter全部语句之前，另一个线程开始执行setter情况，相当于函数头尾加了锁一样。nonatomic不保证setter/getter的原语行，所以你可能会取不到完整的东西。比如setter函数里面该表两个成员变量，如果你nonatomic的话，getter可能会取到只更改了其中一个变量时候的状态。
atomic是线程安全的,nonatomic是线程不安全的。如果只是单线程操作的话用nonatomic最好,因为后者效率高一些。

——————————————————————————————————iOS中网络请求————————————————————————————
iOS中，关于网络请求的接口自下至上有如下几层：
CFSocket
CFNetwork              —>ASIHttpRequest
NSURLConnection        —>AFNetworking
NSURLSession           —>AFNetworking2,Alamofire
NSURLConnection 是基于 CFNetwork 的更高层的封装，提供面向对象的接口，AFNetworking 工作于这一层。
NSURLSession 是 iOS7 中新增的接口，表面上是和 NSURLConnection 并列的，但底层仍然用到了 NSURLConnection 的部分功能 (比如 com.apple.NSURLConnectionLoader 线程)，AFNetworking2 和 Alamofire 工作于这一层。


——————————————————————————————————苹果用Runloop实现的功能—————————————————————
AutoreleasePool
事件响应
手势识别
界面更新
定时器
PerformSelecter
关于GCD

Runloop的实际应用举例：
       AFNetworking、AsyncDisplayKit