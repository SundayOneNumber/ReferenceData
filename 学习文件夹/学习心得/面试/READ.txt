
表单提交 post和get的区别？
1、get方式提交会把参数显示在地址
post方式提交不会把参数显示在地址栏上。（请求体）				
2、get方式敏感信息不安全
   post方式敏感信息相对安全
3、get方式提交，官方限制提交大小仅1KB（但多数浏览器可以提交2KB）
   post方式提交，提交大数据。一般用于附件上传

#import <objc/runtime.h>
runtime——给OC类别，扩展属性
         (关联对象与被关联对象本身的存储并没有直接的关系，它是存储在单独的哈希表中的)
       > 对象地址与AssociationsHashMap哈希表是一一对应的（因此，我们也可以给类对象添加关联对象）
       > 流程： self ---> ObjectAssociationMap对象 ----> ObjectAssociationHashMap

copy、strong、assign存储策略


搜索实现关键字联想（接口端请求获取）
cell根据图片高度来自适应高度，需要服务器端先告诉图片的尺寸，否则无法实现，因为即时刷新效率很低，
swift1.0~2.0区别——字符串获取长度有变：先获取到C的字符串，在获取C字符串的长度
WatchKit使用
视频APP用到的框架以及第三方库
获取iOS设备的内存状况
UIImagePickerController自定义导航栏—因为他也是一个导航控制器，可以修改，其navigationBar
图片渐进加载——大图片会影响性能！

喜欢自定义func myLayoutSubviews()这样是因为系统的LayoutSubviews()不容易控制，在很多情况下会调用，这导致一个可变的frame，出现了可控制性


造成循环引用的三种场景：
原因：可以简单地理解为A引用了B，而B又引用了A，双方都同时保持对对方的一个引用，导致任何时候引用计数都不为0，始终无法释放。
第一种：
第二种：block函数
第三张：委托delegate——平时注意申明代理属性的时候，用assign(MRC)或者weak(ARC)，不能使用retain或者strong


runtime实现机制
runtime是一套比较底层的纯C语言API，属于1个C语言库，包含了很多底层的C语言API。
在我们平时编写的OC代码中，程序运行过程中，其实最终都是转成runtime的C语言代码，runtime算是OC的幕后工作者。
例如：
OC：[[MJPerson alloc]init]=====>
runtime：objc_msgSend(objc_msgSend(“MJPerson”,”allow”),”init”)

runtime用途：
1.在程序运行过程中，动态创建一个类（比如KVO的底层实现—————MJExtension处理数据模型）
2.在程序运行过程中，动态地为某个类添加属性\方法，修改属性值\方法（比如：对类别进行属性扩展，通过改变方法名指针指向来交换方法的实现）
例如：交换方法实现
Method ori_Method = class_getInstanceMethod([NSArray class], @selector(lastObject));
Method my_Method = class_getInstanceMethod([NSArray class], @selector(myLastObject));
method_exchangeImplementations(ori_Method, my_Method);
3.遍历一个类的所有成员变量（属性）\所有方法（因为NSObject在runtime里就是一个结构体）

设计模式：
单例、代理、通知

