Core Graphics 基于 Quartz2D 绘制引擎:
Quartz2D 的内存管理：
   使用含有“create”或“copy”的函数创建的对象，使用完后必须释放，否则将导致内存泄露
   使用不含有“create”或“copy”的函数获取的对象，则不需要释放


在 iOS 中，软件绘图通常是由 Core Graphics 框架来完成。但是在一般情况下，相比 Core Animation 和 OpenGL，Core Graphics 要慢了很多。
软件绘图不仅效率低，还会消耗可观的内存。
CALayer 只需要一些与自己相关的内存：只有它的寄宿图会消耗一定的内存空间。即使直接赋值给 contents 属性一张图片，也不需要增加额外的图片存储大小。如果相同的一张图片被多个图层作为 contents 属性，那么他们会公用同一块内存，而不是复制内存块。

但是一旦你实现了CALayerDelegate协议中的-drawLayer:inContext:方法或者UIView中的-drawRect:方法（其实就是前者的包装方法），图层就创建了一个绘制上下文，这个上下文需
要的大小的内存可从这个算式得出：图层宽*图层高*4字节，宽高的单位均为像素。对于一>个在Retina iPad上的全屏图层来说，这个内存量就是 2048*1526*4字节，相当于12MB内存>，图层每次重绘的时候都需要重新抹掉内存然后重新分配。


提升绘制性能的秘诀在于尽量避免去绘制。
屏幕上允许同时出现图层上限数量大约是几百
“黑板”功能，一般是通过 Core Graphics 实现(随着时间的增加每次重绘需要更多的时间，帧数也会下降)，为了减少不必要的绘制，MAC OS 和 iOS 设备将会把屏幕分为需要重绘的区域和不需要重绘的区域。那些需要重绘的部分被称作“脏区域”。在实际应用中，鉴于非矩形区域边界裁剪和混合的复杂性，通常会区分出包含指定视图的矩形位置，而这个位置就是“脏矩形”
“画板”实现的方式：
1.CAShapeLayer + path 
   优点：
   渲染快速。CAShapeLayer 使用了硬件加速，绘制同一图形会比用 Core Graphics 快很多。
   高效使用内存。一个 CAShapeLayer 不需要像普通 CALayer 一样创建一个寄宿图形，所以无论有多大，都不会占用太多的内存。
   不会被图层边界剪裁掉。
   不会出现像素化
2.只绘制需要绘制的 rect,而不重绘脏矩形 -setNeedsDisplayInRect：
