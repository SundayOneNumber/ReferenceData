Runloop实现自动释放池、延迟回调、触摸事件、屏幕刷新等功能

runloop
使用runloop的目的是让你的线程在有工作的时候忙于工作，而没有工作的时候处于休眠状态,保证程序执行的线程不会被系统终止。
每个线程，包括程序的主线程都有与之对应的run loop object,只有辅助线程才需要显示的运行它的run loop,在Cocoa程序中，主线程会自动创建并运行它run loop,最为一般应用程序启动过程的一部分。
runloop还可以在loop处于循环中的同时响应其他输入源，比如界面控制的按钮、手势等。（另外AFNetworking中，实现常驻服务线程的方法是通过addPort:forMode:使得先线程一直处于监听服务端口，以便于及时处理服务器端通过该端口传过来的信息，能够被及时处理）
1：通过do-while死循环让程序持续运行：接收用户输入，调度处理事件时间。（目前，个人理解，runloop的原理，是通过死循环，不停的调用runMode:方法，来实现对不同模式下的事件源进行检测，当有事件源发生时，就会及时的调用相应地处理事件源方法）
2：通过mach_msg()让runloop没事时进入trap状态，节省CPU资源

使用情况：
1.使用端口或自定义输入源和其他线程通信
2.使用线程的定时器 
3.cocoa中使用任何performSelector...的方法
4.使线程周期性工作

Runloop接收两种事件源：input sources和timer sources
   input sources传递异步事件，通常是来自其他线程和不同的程序中的消息
   timer sources(定时器)传递同步事件(重复执行或者在特定时间上触发)。

注意：
Run loop模式是所有要监视的输入源和定时源以及要通知的run loop注册观察者的集合。每次运行你的run loop，你都要指定（无论显示还是隐式）其运行个模式。在run loop运行过程中，只有和模式相关的源才会被监视并允许他们传递事件消息。（类似的，只有和模式相关的观察者会通知run loop的进程）。和其他模式关联的源只有在run loop运行在其模式下才会运行，否则处于暂停状态。
RunLoop只能运行在一种mode下，如果要换mode，当前的loop也需要停下重启成新的

Cocoa中的NSRunloop类不是线程安全的
CFRunloopRef（core foundation）是线程安全的，而且两种类型的run loop完全可以混合使用
runMode:deforeDate:在某个期限前运行
CFRunLoopStop(CFRunLoopGetCurrent());//目前，这里是子线程，是行的通的
//CFRunLoopStop([[NSRunLoop mainRunLoop] getCFRunLoop]);//你在主线程的RunLoop中添加了新的源，但你并没有权限停止它
CFRunLoopStop，在测试的时候，很管用的，不然，不停止runloop，runloop就会一直处于运行状态，使得do{runloop runMode后面的代码，在默认的1分钟内不会被执行，从而降低CPU的消耗，但是可以通过CFRunLoopRunInMode修改停留时间}，或者通过[[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];来设置超时时间
另外，如果通过runMode:beforeDate:来设置超时时间，则在超时时间之前，该runloop一直处于等待设定的mode类型事件源的发生。

performSelecter
当调用NSObject的performSelecter:afterDelay:后，实际上其内部会创建一个Timer并添加到当前线程的Runloop中，所以如果当前线程没有Runloop，则这个方法会失效。
当调用performSelector:onThread:时，实际上其会创建一个Timer加到对应的线程去，同样的，如果对应线程没有Runloop该方法也会失效。

BOOL ret =[myRunLoop runMode:@"OREORE_MODE" beforeDate:[NSDate distantFuture]];
当通过runMode来对某个模式下的runloop进行检测，若与设定好的mode模式相同的事件一直在发生，则默认该语句所在的do{}while()循环一次的时间为1分钟。

如果定时器所在的模式当前未被run loop监视，那么定时器将不会开始直到run loop运行在相应的模式下

总结：
线程与Runloop之间是一一对应的，其关系是保存在一个全局的Dictionary里。线程刚创建时并没有Runloop，如果你不主动获取，那它一直都不会有。RunLoop 的创建是发生在第一次获取时，RunLoop 的销毁是发生在线程结束时。你只能在一个线程的内部获取其 RunLoop（主线程除外）。
一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个 Source/Timer/Observer。每次调用 RunLoop 的主函数时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode。如果需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的 Source/Timer/Observer，让其互不影响。
RunLoop只能运行在一种mode下，如果要换mode，当前的loop也需要停下重启成新的

问题：
目前，仍然不了解，如何在runMode运行某个模式下，去监听或者处理另一模式的事件。
