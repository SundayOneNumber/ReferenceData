
1. 网络图片显示大体步骤：
  1> 下载图片
  2> 图片处理
  3> 写入磁盘
  4> 从磁盘读取数据到内核缓冲区
  5> 从内核缓冲区复制到用户空间（内存级别拷贝）
  6> 解压缩为位图（耗 cpu 较高，且一般在主线程进行解码过程）
  7> 如果位图数据不是字节对齐的，Core Animation 会 copy 一份位图数据并进行字节对齐   
  8> Core Animation 渲染解压缩过的位图（这是因为 UIImageView 通过 image 属性，来设置其 layer 层的 content）
  以上4、5、6、7、8步是在 UIImageView 的 setImage 时进行的，所以默认在主线程上运行的（iOS UI 操作必须在主线程执行）。

FastImageCache 对 5、7点进行了优化：
   Core Animation在某些情况下渲染前会先拷贝一份图像数据，通常是在图像数据非字节对齐的情况下会进行拷贝处理，官方文档没有对这次拷贝行为作说明，模拟器和Instrument里有高亮显示“copied images”的功能，但似乎它有bug，即使某张图片没有被高亮显示出渲染时被copy，从调用堆栈上也还是能看到调用了CA::Render::copy_image方法：
  那什么是字节对齐呢，按我的理解，为了性能，底层渲染图像时不是一个像素一个像素渲染，而是一块一块渲染，数据是一块块地取，就可能遇到这一块连续的内存数据里结尾的数据不是图像的内容，是内存里其他的数据，可能越界读取( 越界读取：是指读取不属于自己的数据，如读取的字节多余分配给目标变量的字节数 )导致一些奇怪的东西混入，所以在渲染之前CoreAnimation要把数据拷贝一份进行处理，确保每一块都是图像数据，对于不足一块的数据置空。
（字节对齐方式：主要是在创建上图解码的过程中，CGBitmapContextCreate函数的bytesPerRow参数必须传64的倍数）

通用的解压缩方案：
   主体的思路是在子线程，将原始的图片渲染层一张新的可以字节显示的图片，来获取一个解压缩过的图片
   （这么做的优点是在setImage的时候系统省去了上面的第6步，缺点就是图片占用的空间变大。）